#' @title stanedit
#' @description
#' \code{stanedit} prepares stan model code for programmatically editing.
#'
#' @param object either a `stanmodel` object as generated by
#'   [rstan::stan_model()] or a `CmdStanModel` object as generated by
#'   [cmdstanr::cmdstan_model()], or a character vector representing model code.
#' @param filename name of a file containing model code, if `object` is not
#'   given.
#' @return A \code{{stanedit}} object containing clean model code. This will
#'   have some formatting applied to it for further processing so line numbers
#'   may not correspond to the original model, and comments will be removed.
#' @examples
#' model_file_name <- system.file(package = "stanedit", "XXX.bi")
#' PZ <- stanedit(filename = model_file_name)
#' @export
stanedit <- function(object, filename) {
  if (!missing(object) + !missing(filename) != 1) {
    stop("Exactly one of 'object' or 'filename' must be given")
  }
  if (!missing(filename)) {
    model <- readLines(filename)
  } else if (is.character(model)) {
    model <- object
  } else if (is(object, "stanmodel")) {
    model <- object@model_code
  } else if (is(object, "CmdStanModel")) {
    model <- capture.output(object$format(canonicalize = TRUE))
  } else {
    stop("Unknown object type")
  }

  return(clean_model(model))
}

#' @name clean_model
#' @title Strip model code to its bare bones
#'
#' @description
#' Cleans the model by working out correct indents, removing long comments and
#'   merging lines (if desired)
#' @param x a \code{\link{stanedit}} object
#' @importFrom checkmate assert_character
#' @return the updated \code{stanedit} object
#' @seealso \code{\link{stanedit}}
#' @keywords internal
clean_model <- function(x) {
  assert_character(x)
  x <- as.character(x) ## strip stanedit class

  ## strip comments starting with //
  x <- sub("//.*$", "", x)

  ## remove long comments and merge lines
  i <- 1
  comment <- FALSE # flag to denote whether a line starts inside a comment
  while (i <= length(x)) {
    ## remove sections delimited by /* ... */ within lines
    x[i] <- gsub("/\\*[^(\\*)]*\\*/", "", x[i])
    if (comment) { ## we're inside a comment
      if (grepl("\\*/", x[i])) { ## comment ends but does not start on this line
        ## Remove everything before */ and unset the 'comment' flag so that in
        ## the next line we know that we're not in a comment any longer
        x[i] <- sub("^.*\\*/", "", x[i])
        comment <- FALSE
      } else { ## comment does not end on this line -- we remove the line
        x <- x[-i]
      }
    }

    ## if 'comment' is still true, we're inside the comment -- move on
    if (!comment) { ## we're not inside a comment
      if (grepl("/\\*", x[i])) {
        ## comment starts but does not end on this line.
        ## Remove everything after /* and set the 'comment' flag so that in the
        ## next line we know we're still inside the comment
        x[i] <- sub("/\\*.*$", "", x[i])
        comment <- TRUE
      }
      if (!grepl("[{};][[:space:]]*$", x[i]) &&
          !(grepl("#", x[i])) &&
          i < length(x)) {
        ## line not finished -- merge lines
        x[i] <- paste(x[i], x[i + 1])
        x <- x[-(i + 1)]
      } else {
        i <- i + 1
      }
    }
  }

  ## remove multiple spaces
  x <- gsub("[[:space:]]+", " ", x)
  ## make sure there is a line break after opening braces
  x <- gsub("\\{", "{\n", x)
  ## make sure there is a line break before closing braces
  x <- gsub("\\}", "\n}", x)
  ## add newlines after semicolons
  x <- gsub(";", ";\n", x)
  ## split along newlines
  x <- unlist(strsplit(x, "\n"))
  ## remove trailing spaces
  x <- gsub("[[:space:]]*$", "", x)
  ## remove initial spaces
  x <- gsub("^[[:space:]]*", "", x)
  ## remove empty lines
  x <- x[x != ""]

  ## check
  opening_curls <- length(grep("\\{", x))
  closing_curls <- length(grep("\\}", x))
  if (opening_curls != closing_curls) {
    warning("Model contains unbalanced braces.")
  }
  model <- structure(x, class = "stanedit")

  return(model)
}

#' @title Insert lines in a stan model
#' @description
#' Inserts one or more lines into a libbi model. If one of \code{before} or
#'   \code{after} is given, the line(s) will be inserted before or after a given
#'   line number or block name, respectively. If one of \code{at_beginning of}
#'   or \code{at_end_of} is given, the lines will be inserted at the
#'   beginning/end of the block, respectively.
#'
#' @param x a \code{\link{stanedit}} object
#' @param lines vector or line(s)
#' @param before line number before which to insert line(s)
#' @param after line number after which to insert line(s)
#' @param at_beginning_of block at the beginning of which to insert lines(s)
#' @param at_end_of block at the end of which to insert lines(s)
#' @return the updated \code{stanedit} object
#' @importFrom checkmate assert_class
#' @seealso \code{\link{stanedit}}
#' @examples
#' model_file_name <- system.file(package = "rbi", "PZ.bi")
#' PZ <- stanedit(filename = model_file_name)
#' PZ <- insert_lines(PZ, lines = "noise beta", after = 8)
#' @export
insert_lines <- function(x, lines, before, after, at_beginning_of, at_end_of) {
  assert_class(x, "stanedit")
  args <- match.call()
  arg_name <- setdiff(names(args), c("", "x", "lines"))
  if (length(arg_name) != 1) {
    stop(
      "insert_lines needs exactly three arguments, 'x', 'lines' and one of ",
      "'before', 'after', 'at_beginning_of' or 'at_end_of'"
    )
  }
  arg <- eval.parent(args[[arg_name]])
  if (is.numeric(arg)) arg <- as.integer(arg)

  if (arg_name %in% c("before", "after") && is.integer(arg)) {
    if (arg_name == "before") {
      after <- before - 1
    }
    if (after > length(x)) {
      stop("model only has ", length(x), " lines, higher requested.")
    }
  } else {
    block_lines <- find_block(x, arg)
    if (length(block_lines) == 0) {
      x <- add_block(x, arg)
      block_lines <- find_block(x, arg)
    }
    if (arg_name == "before") {
      after <- block_lines[1] - 1
    } else if (arg_name == "after") {
      after <- block_lines[length(block_lines)]
    } else if (arg_name == "at_beginning_of") {
      after <- block_lines[1]
    } else if (arg_name == "at_end_of") {
      after <- block_lines[length(block_lines)] - 1
    } else {
      stop("Unknown argument: ", arg_name)
    }
  }

  if (after == 0) {
    x <- c(lines, x)
  } else if (after == length(x)) {
    x <- c(x[1:after], lines)
  } else {
    x <- c(x[1:after], lines, x[(after + 1):length(x)])
  }
  return(clean_model(x))
}


#' @title Remove line(s) and/or block(s) in a libbi model
#' @description
#' Removes one or more lines in a libbi model.
#'
#' @param x a \code{\link{stanedit}} object
#' @param what either a vector of line number(s) to remove, or a vector of
#'   blocks to remove (e.g., "parameter")
#' @param only only remove lines assigning given names (as a vector of character
#'   strings)
#' @param type which types of lines to remove, either "all", "sample" (i.e.,
#'   lines with a "~") or "assignment" (lines with a "<-" or "=") (default:
#'   "all")
#' @param preserve_shell if TRUE (default: FALSE), preserve the definition of a
#'   block even if all lines are removed; this is useful to preserve options
#'   passed to a \code{transition} or \code{ode} block
#' @return the updated \code{stanedit} object
#' @importFrom checkmate assert_class
#' @seealso \code{\link{stanedit}}
#' @examples
#' model_file_name <- system.file(package = "rbi", "PZ.bi")
#' PZ <- stanedit(filename = model_file_name)
#' PZ <- remove_lines(PZ, 2)
#' @export
remove_lines <- function(x, what, only, type = c("all", "assignment", "sample"),
                         preserve_shell = FALSE) {
  assert_class(x, "stanedit")
  if (missing(what)) {
    stop("'what' must be given")
  }
  type <- match.arg(type)
  to_remove <- c()
  if (is.numeric(what)) {
    to_remove <- what
  } else if (is.character(what)) {
    to_remove <- find_block(x, what, inner = preserve_shell)
  } else {
    stop("'what' must be a numeric or character vector.")
  }

  operators <- list(assignment = c("=", "<-"), sample = "~")

  ## check if we don't want to remove everything
  if (length(to_remove) > 0 && (type != "all" || !missing(only))) {
    if (type == "all") {
      op_types <- unlist(operators)
    } else {
      op_types <- operators[[type]]
    }
    pattern <- paste0(
      "^(const)?[[:space:]]*([A-Za-z_0-9[\\]][[:space:]A-Za-z_0-9,[\\]]*)",
      "(", paste(op_types, collapse = "|"), ")"
    )
    assign_lines <- grep(pattern, x[to_remove], perl = TRUE)
    assign_vars <- sub(paste0(pattern, ".*$"), "\\2",
      x[to_remove][assign_lines],
      perl = TRUE
    )
    assign_vars <- sub("[[:space:]]", "", sub("\\[.*]", "", assign_vars))
    if (!missing(only)) {
      assign_lines <- assign_lines[assign_vars %in% only]
    }
    if (is.character(what) && !preserve_shell &&
      length(assign_lines) == length(to_remove) - 2) {
      assign_lines <- c(1, assign_lines, length(to_remove))
    }
    to_remove <- to_remove[assign_lines]
  }

  if (length(to_remove) > 0) {
    x <- x[-to_remove]
  }

  return(clean_model(x))
}


#' @title Writes a bi model to a file.
#' @description
#' Writes a bi model to a file given by \code{filename}. The extension '.bi'
#'   will be added if necessary.
#'
#' @param x a \code{\link{stanedit}} object, or a \code{\link{libbi}} object
#'   containing a model
#' @param filename name of the file to be written
#' @param update.name whether to update the model name with the file name
#' @return the return value of the \code{\link{writeLines}} call.
#' @seealso \code{\link{stanedit}}
#' @importFrom checkmate assert_class
#' @examples
#' model_file_name <- system.file(package = "rbi", "PZ.bi")
#' PZ <- stanedit(filename = model_file_name)
#' new_file_name <- tempfile("PZ", fileext = ".bi")
#' write_model(PZ, new_file_name)
#' @export
write_model <- function(x, filename, update.name = TRUE) {
  assert_class(x, "stanedit")
  if (!grepl("\\.stan$", filename)) {
    filename <- paste(filename, "bi", sep = ".")
  }
  model_name <- sub("\\.stan$", "", basename(filename))
  if (update.name) {
    x <- set_name(x, model_name)
  }

  writeLines(print(x, screen = FALSE), con = filename, sep = "\n")
}

#' @title Find a block in a stan model
#'
#' @description
#' Finds a block and returns the range of line numbers encompassed by that
#'   block.
#' @return an integerr vector, the range of line numbers
#' @seealso \code{\link{stanedit}}
#' @keywords internal
#' @param x a \code{\link{stanedit}} object
#' @param name of the block to find
#' @param inner only return the inner part of the block (not the block
#'   definition)
#' @importFrom checkmate assert_class
find_block <- function(x, name, inner = FALSE) {
  assert_class(x, "stanedit")
  lines <- as.character(x)
  sub_regexp <- paste0(
    "^[[:space:]]*(sub[[:space:]]+)?[[:space:]]*", name,
    "([[:space:]][a-zA-Z0-9_\\.]+)?[[:space:]]*(\\(.*\\))?[[:space:]]*\\{"
  )
  sub_line <- grep(sub_regexp, lines)
  if (length(sub_line) == 1) {
    lines[sub_line] <- sub(sub_regexp, "", lines[sub_line])
    open_braces <- 1
    line <- sub_line - 1
    while (open_braces > 0) {
      line <- line + 1
      open_braces <- open_braces +
        nchar(gsub("\\}", "", lines[line])) -
        nchar(gsub("\\{", "", lines[line]))
    }
    if (inner) {
      return((sub_line + 1):(line - 1))
    }
    return(sub_line:line)
  } else {
    return(integer(0))
  }
}

##' Remove everything between opening/closing characters, including nesting
##'
##' Useful for e.g. removing bounds, array indices etc.
##' @param x a character vector
##' @param opening opening character
##' @param closing closing character
##' @return stanedit object with the bits removed
##' @importFrom checkmate assert_class assert_character
remove_contained <- function(x, opening, closing) {
  assert_character(x)
  assert_character(opening)
  assert_character(closing)
  ## filter out lines that contain the opening character(s)
  line_ids <- grep(paste0("[", opening, "]"), x)
  for (line_id in line_ids) {
    chars <- strsplit(x[line_id], split = "")[[1]]
    paren_level <- 0
    result <- ""
    for (char in chars) {
      if (char == opening) {
        paren_level <- paren_level + 1
      } else if (char == closing && paren_level > 0) {
        paren_level <- paren_level - 1
      } else if (paren_level == 0) {
        result <- paste0(result, char)
      }
    }
    x[line_id] <- result
  }
  return(x)
}

#' @title Strip model code to its bare bones
#' @keywords internal
#' @param x a character vector
#' @return a character vector of the model code
barebones <- function(x) {
  assert_character(x)
  ## strip out unneeded characters
  x <- remove_contained(x, "[", "]")
  x <- remove_contained(x, "(", ")")
  x <- remove_contained(x, "<", ">")
  ## remove assignments
  x <- sub("[[:space:]]*[*-/+]?[=~].*$", "", x)
  ## remove trailing semicolons
  x <- sub(";$", "", x)
  ## remove trailing whitespace
  x <- sub("[[:space:]]*$", "", x)
  return(x)
}

#' @title Find the declaration of a variable in a stan model
#'
#' @description
#' Finds a block and returns the range of line numbers encompassed by that
#'   block.
#' @return an integer, the line numbes where the variable is declared; an empty
#'   integer if the declaration is not found
#' @seealso \code{\link{stanedit}}
#' @keywords internal
#' @param x a \code{\link{stanedit}} object
#' @param name of the block to find
#' @param inner only return the inner part of the block (not the block
#'   definition)
#' @importFrom checkmate assert_class
#' @export
find_declaration <- function(x, name) {
  assert_class(x, "stanedit")
  lines <- barebones(as.character(x))

  ## remove leading whitespace
  declaration <- setdiff(
    grep(
      paste0(
        "^(array[[:space:]]+)?[a-z]+[[:space:]]+",
        name,
        "[[:space:]]*$"),
      lines
    ),
    union(
      grep("^return[[:space:]]", lines),
      grep("[{}]", lines)
    )
  )
  return(declaration)
}

##' Extract the variables declared in a stan model
##'
##' @param x a \code{\link{stanedit}} object
##' @param block character (optional), the block or blocks in which to search;
##'   by default the whole model will be searched
##' @return a character vector of variable names
##' @export
get_vars <- function(x, block) {
  assert_class(x, "stanedit")
  if (missing(block)) {
    lines <- as.character(x)
  } else {
    lines <- get_block(x, block)
  }
  lines <- barebones(lines)
  declarations <- setdiff(
    grep(
      paste0(
        "^(array[[:space:]]+)?[a-z]+[[:space:]]+[^[:space:]]+[[:space:]]*$"),
      lines
    ),
    union(
      grep("^return[[:space:]]", lines),
      grep("[{}]", lines)
    )
  )
  vars <- sub("^.*[[:space:]]([^[:space:]]+)$", "\\1", lines[declarations])
  return(vars)
}

#' @title Get the contents of a block in a stan model
#'
#' @description
#' Returns the contents of a block in a stan model as a character vector of
#'   lines.
#' @return a character vector of the lines in the block
#' @param x a \code{\link{stanedit}} object
#' @param name name of the block
#' @param shell if TRUE (default:FALSE), will return the shell (i.e., the
#'   definition of the block) as well as content; this is useful, e.g., to see
#'   options passed to a \code{transition} or \code{ode} block
#' @importFrom checkmate assert_class
#' @export
get_block <- function(x, name, shell = FALSE) {
  assert_class(x, "stanedit")
  if (missing(name)) {
    stop("The name of the block must be provided as 'name'")
  }
  block <- find_block(x, name)
  if (length(block) > 0) {
    lines <- as.character(x[block])
    if (!shell) {
      lines <- lines[-c(1, length(lines))]
    }
    return(lines)
  } else {
    return(character(0))
  }
}

#' @name add_block
#' @title Add a block to a stan model
#'
#' @description
#' Add a block to a stan model. If that block exists, it will be removed first.
#' @return a \code{\link{stanedit}} object containing the new block
#' @param x a \code{\link{stanedit}} object
#' @param name name of the block
#' @param lines character vector, lines in the block
#' @param options any options to the block
#' @importFrom checkmate assert_class
#' @export
add_block <- function(x, name, lines, options) {
  assert_class(x, "stanedit")
  x <- remove_lines(x, what = name)
  if (missing(lines)) {
    lines <- c()
  }
  x <- c(
    x[seq_len(length(x) - 1)],
    ifelse(
      missing(options),
      paste("sub", name, "{"),
      paste("sub", name, paste0("(", options, ")", "{"))
    ),
    paste(lines, sep = "\n"), "}", "}"
  )
  clean_model(x)
}

#' @name var_names
#' @title Get variable names in a stan model
#' @description
#' Get variable names of one or more type(s)
#'
#' This returns all variable names of a certain type ("param", "state", "obs",
#'   "noise", "const") contained in the model of a \code{\link{libbi}} object
#' @param x a \code{\link{stanedit}} object
#' @param vars a character vector of variable names; if given, only these
#'   variables names will be considered
#' @param type a character vector of one or more types
#' @param dim logical; if set to TRUE, names will contain dimensions in brackets
#' @param opt logical; if set to TRUE, names will contain options (e.g.,
#'   has_output)
#' @param aux logical; if set to TRUE, auxiliary names will be returned
#' @return a character vector ofvariable names
#' @rdname var_names
#' @export
var_names <- function(x, vars, type, dim = FALSE, opt = FALSE, aux = FALSE) {
  names_vec <- c()
  if (missing(type)) {
    type <- c("param", "state", "input", "const", "obs", "noise")
  }

  for (for_type in type) {
    line_nbs <- grep(paste0("^[[:space:]]*", for_type, "[[:space:]]"), x)
    if (length(line_nbs) > 0) {
      ## remove qualifier
      name <- sub(
        paste0("^[[:space:]]*", for_type, "[[:space:]]"), "", x[line_nbs]
      )
      clean_name <- name
      if (!dim) {
        ## remove dimensions
        name <- gsub("\\[[^]]*\\]", "", name)
      }
      clean_name <- gsub("\\[[^]]*\\]", "", clean_name)
      if (!opt) {
        ## remove options
        name <- sub("\\([^)]*\\)", "", name)
      }
      clean_name <- sub("\\([^)]*\\)", "", clean_name)
      if (for_type == "const") {
        ## remove assignments
        name <- sub("=.*$", "", name)
      }
      ## remove spaces
      name <- gsub("[[:space:]]", "", name)
      clean_name <- gsub("[[:space:]]", "", clean_name)

      ## add to vector
      if (missing(vars)) {
        names_vec <- c(names_vec, name)
      } else {
        names_vec <- c(names_vec, name[clean_name %in% vars])
      }
    }
  }
  if (!aux) {
    names_vec <- grep("^__", names_vec, invert = TRUE, value = TRUE)
  }
  return(names_vec)
}

#' @title Print the lines of a stan model
#'
#' @description
#' Prints all lines in a stan model
#' @param x a \code{\link{stanedit}} object
#' @param spaces number of spaces for indentation
#' @param screen whether to print to screen (default: TRUE). In that case, line
#'   numbers will be added; otherwise, a character vector will be returned.
#' @param ... ignored
#' @rdname print
#' @name print.stanedit
#' @return if \code{screen} is \code{FALSE}, a character vector of model lines
#' @keywords internal
#' @export
print.stanedit <- function(x, spaces = 2, screen = interactive(), ...) {
  x <- clean_model(x)
  if (length(x) == 0) {
    if (screen) cat("// empty", "\n")
  } else {
    vec <- c()
    indent <- 0
    for (i in seq_along(x)) {
      if (grepl("\\}", x[i])) indent <- indent - 1
      indent_spaces <- paste(rep(" ", max(0, indent * spaces)), collapse = "")
      vec <- c(vec, paste0(indent_spaces, x[i]))
      if (grepl("\\{", x[i])) {
        indent <- indent + 1
      }
    }
    if (screen) {
      line_num_indent <- nchar(as.character(length(vec)))
      line_nums <- vapply(seq_along(vec), function(y) {
        paste0(
          c(rep(" ", line_num_indent - nchar(as.character(y))), y),
          collapse = ""
        )
      }, character(1))
      cat(paste(paste(line_nums, vec, sep = ": "), collapse = "\n"), sep = "\n")
    } else {
      return(vec)
    }
  }
}

#' @name is_empty
#' @title Check if a model is empty
#' @description
#' Checks if a model is empty (i.e., has been initialised without any content)
#'
#' @param x a \code{\link{stanedit}} object
#' @return TRUE or FALSE, depending on whether the model is empty
#' @seealso \code{\link{stanedit}}
#' @keywords internal
#' @rdname is_empty
is_empty <- function(x) {
  return(length(x) == 0)
}

#' @name Extract_assign.stanedit
#' @rdname Extract_assign.stanedit
#' @title Subset and replace model lines
#' @aliases `[<-.stanedit`
#' @description
#' Extracts a subset of lines from the model and assigns new character strings.
#' @param x A stanedit
#' @param i A vector of line numbers
#' @param ... ignored
#' @return the updated \code{stanedit} object
#' @examples
#' model_file_name <- system.file(package = "rbi", "PZ.bi")
#' PZ <- stanedit(filename = model_file_name)
#' PZ[3:4] <- c("const e = 0.4", "const m_l = 0.05")
#' @export
#' @param value A vector of the same length as \code{i}, containing the
#'   replacement strings
`[<-.stanedit` <- function(x, i, ..., value) {
  model_char <- as.character(x)
  if (is.null(value)) {
    model_char <- model_char[-i]
  } else {
    model_char[i] <- value
  }
  return(clean_model(model_char))
}

#' @name Extract.stanedit
#' @rdname Extract.stanedit
#' @title Subset model lines
#' @aliases `[.stanedit`
#' @description
#' Extracts a subset of lines from the model.
#' @param x A stanedit
#' @param i A vector of line numbers
#' @param ... ignored
#' @return a character string of the extracted model lines(s)
#' @examples
#' model_file_name <- system.file(package = "rbi", "PZ.bi")
#' PZ <- stanedit(filename = model_file_name)
#' PZ[3:4]
#' @export
`[.stanedit` <- function(x, i, ...) {
  model_char <- as.character(x)
  if (missing(i)) {
    return(model_char)
  } else if (any(i >= 0)) {
    return(model_char[i])
  } else {
    return(clean_model(model_char[i]))
  }
}

#' @name Equals.stanedit
#' @rdname Equals.stanedit
#' @title Check if two models are equal
#' @aliases `==.stanedit`
#' @description
#' Ignores differences in the model name.
#' @param e1 a \code{\link{stanedit}}
#' @param e2 a \code{\link{stanedit}}
#' @param ... ignored
#' @examples
#' model_file_name <- system.file(package = "rbi", "PZ.bi")
#' PZ <- stanedit(filename = model_file_name)
#' PZ == PZ # TRUE
#' @export
#' @return TRUE or FALSE, depending on whether the models are equal or not
`==.stanedit` <- function(e1, e2, ...) { ## nolint
  return(
    length(e1) == length(e2) &&
    all(get_block(e1, "model") == get_block(e2, "model"))
  )
}

#' @name Unequals.stanedit
#' @rdname Unequals.stanedit
#' @title Check if two models are unequal
#' @aliases `!=.stanedit`
#' @description
#' Ignores differences in the model name.
#' @param e1 a \code{\link{stanedit}}
#' @param e2 a \code{\link{stanedit}}
#' @param ... ignored
#' @examples
#' model_file_name <- system.file(package = "rbi", "PZ.bi")
#' PZ <- stanedit(filename = model_file_name)
#' PZ != PZ # FALSE
#' @export
#' @return TRUE or FALSE, depending on whether the models are equal or not
`!=.stanedit` <- function(e1, e2, ...) { ## nolint
  return(!(e1 == e2))
}
